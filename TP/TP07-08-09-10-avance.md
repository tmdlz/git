# TP07 - Git Stash - Sauvegarde Temporaire

## üéØ Objectifs

- Utiliser `git stash` pour sauvegarder temporairement
- Comprendre `stash pop` vs `stash apply`
- G√©rer plusieurs stashes
- R√©cup√©rer du code stash√©

## üìù Contexte

Vous √™tes en plein d√©veloppement d'une fonctionnalit√© quand on vous demande de corriger un bug urgent sur une autre branche. Vous devez mettre de c√¥t√© votre travail en cours sans le commiter.

## üîß Instructions

### √âtape 1 : Setup

1. Cr√©ez `urgent-fix-project` et initialisez Git
2. Cr√©ez `app.js` :
```javascript
function calculateTotal(items) {
    return items.reduce((sum, item) => sum + item.price, 0);
}
```
3. Commitez "Add total calculation"

### √âtape 2 : Travail en cours

4. Modifiez `app.js` pour ajouter :
```javascript
function applyDiscount(total, discount) {
    // TODO: implement discount logic
    return total - (total * discount / 100);
}
```
5. Cr√©ez `discount.js` :
```javascript
const DISCOUNT_CODES = {
    'SUMMER': 20,
    'WELCOME': 10
};
```
6. NE COMMITEZ PAS - v√©rifiez avec `git status`

### √âtape 3 : Urgence !

7. Utilisez `git stash` pour mettre de c√¥t√© vos modifications
8. V√©rifiez que le working directory est propre
9. V√©rifiez que vos modifications ont disparu

### √âtape 4 : Correction du bug

10. Corrigez un bug dans `app.js` :
```javascript
function calculateTotal(items) {
    if (!items || items.length === 0) return 0;
    return items.reduce((sum, item) => sum + item.price, 0);
}
```
11. Commitez "Fix: handle empty items array"

### √âtape 5 : R√©cup√©ration du travail

12. Utilisez `git stash pop` pour r√©cup√©rer vos modifications
13. V√©rifiez que vos deux fichiers sont de retour
14. V√©rifiez la liste des stashes

### √âtape 6 : Multiple stashes

15. Modifiez `app.js` pour ajouter des commentaires
16. Stashez avec un message : `git stash save "WIP: adding comments"`
17. Cr√©ez `tests.js` avec du contenu
18. Stashez avec un message : `git stash save "WIP: test suite"`
19. Listez tous les stashes

### √âtape 7 : Gestion des stashes

20. Appliquez le premier stash SANS le supprimer
21. V√©rifiez qu'il est toujours dans la liste
22. Supprimez le stash manuellement
23. Appliquez et supprimez le second stash avec `pop`

### √âtape 8 : Stash avanc√©

24. Modifiez plusieurs fichiers
25. Stashez uniquement les fichiers track√©s (pas les nouveaux)
26. V√©rifiez qu'un nouveau fichier n'est pas stash√©
27. Stashez TOUT y compris les fichiers non-track√©s

## ‚úÖ Validation

```bash
# Liste des stashes
git stash list

# Contenu d'un stash
git stash show -p stash@{0}

# √âtat du working directory
git status
```

---

# TP08 - Git Revert - Annuler des Commits

## üéØ Objectifs

- Utiliser `git revert` pour annuler des commits
- Comprendre la diff√©rence avec `git reset`
- G√©rer des reverts en cascade
- R√©soudre des conflits de revert

## üìù Contexte

Vous avez d√©ploy√© une feature bugg√©e en production. Vous devez l'annuler proprement sans casser l'historique (d'autres d√©veloppeurs ont d√©j√† pull).

## üîß Instructions

### √âtape 1 : Setup du projet

1. Cr√©ez `production-app` et initialisez Git
2. Cr√©ez `config.js` :
```javascript
const config = {
    apiUrl: 'https://api.example.com',
    version: '1.0.0'
};
```
3. Commitez "Initial config"

### √âtape 2 : Ajout de features

4. Modifiez `config.js` :
```javascript
const config = {
    apiUrl: 'https://api.example.com',
    version: '1.1.0',
    timeout: 5000
};
```
5. Commitez "Add timeout config"

6. Ajoutez :
```javascript
    retryAttempts: 3
```
7. Commitez "Add retry logic"

8. Modifiez :
```javascript
    version: '1.2.0'
```
9. Commitez "Bump to version 1.2.0"

### √âtape 3 : Probl√®me d√©tect√© !

10. Affichez l'historique
11. Le commit "Add retry logic" cause des bugs
12. Utilisez `git revert` sur ce commit sp√©cifique
13. V√©rifiez le fichier - retry devrait avoir disparu
14. V√©rifiez l'historique - un nouveau commit de revert appara√Æt

### √âtape 4 : Revert multiple

15. Cr√©ez `feature.js` :
```javascript
function newFeature() {
    console.log('New feature');
}
```
16. Commitez "Add new feature"

17. Modifiez `config.js` pour ajouter :
```javascript
    enableNewFeature: true
```
18. Commitez "Enable new feature in config"

19. Revertez les DEUX derniers commits en une fois

### √âtape 5 : Conflit de revert

20. Cr√©ez `database.js` :
```javascript
const db = { host: 'localhost' };
```
21. Commitez "Add database config"

22. Modifiez :
```javascript
const db = { 
    host: 'localhost',
    port: 5432 
};
```
23. Commitez "Add database port"

24. Modifiez :
```javascript
    port: 3306
```
25. Commitez "Change to MySQL port"

26. Revertez "Add database port" - conflit attendu
27. R√©solvez le conflit manuellement
28. Finalisez le revert

### √âtape 6 : Revert d'un revert

29. Listez l'historique
30. Identifiez un commit de revert
31. Revertez ce revert (r√©-applique les changements)
32. V√©rifiez le r√©sultat

## ‚úÖ Validation

```bash
# Voir les commits de revert
git log --oneline | grep -i revert

# Comparer avant/apr√®s un revert
git diff <commit-avant-revert> HEAD
```

---

# TP09 - Git Rebase - Historique Propre

## üéØ Objectifs

- Comprendre et utiliser `git rebase`
- Nettoyer l'historique avant merge
- Comparer rebase vs merge
- G√©rer les conflits de rebase

## üìù Contexte

Vous travaillez sur une feature branch depuis plusieurs jours. La branche main a √©volu√©. Vous voulez int√©grer ces changements mais garder un historique lin√©aire et propre.

## üîß Instructions

### √âtape 1 : Setup

1. Cr√©ez `rebase-demo` et initialisez Git
2. Cr√©ez `main.js` :
```javascript
console.log('App v1');
```
3. Commitez "Initial version"

### √âtape 2 : Feature branch

4. Cr√©ez et basculez sur `feature/new-ui`
5. Modifiez `main.js` :
```javascript
console.log('App v1');
console.log('Loading new UI...');
```
6. Commitez "Start new UI"

7. Cr√©ez `ui.js` :
```javascript
const UI = { theme: 'dark' };
```
8. Commitez "Add UI config"

### √âtape 3 : √âvolution de main

9. Retournez sur `main`
10. Modifiez `main.js` :
```javascript
console.log('App v1.1');
```
11. Commitez "Update version on main"

12. Cr√©ez `utils.js` :
```javascript
function log(msg) { console.log(msg); }
```
13. Commitez "Add utils on main"

### √âtape 4 : Visualisation

14. Affichez le graphe de branches
15. Observez que feature/new-ui et main ont diverg√©

### √âtape 5 : Rebase

16. Basculez sur `feature/new-ui`
17. Rebasez sur `main` : `git rebase main`
18. Observez les messages
19. V√©rifiez l'historique - il devrait √™tre lin√©aire

### √âtape 6 : Rebase avec conflits

20. Sur `feature/new-ui`, modifiez `main.js` :
```javascript
console.log('App v2.0');
console.log('Loading new UI...');
```
21. Commitez "Update to v2 on feature"

22. Retournez sur `main`, modifiez `main.js` :
```javascript
console.log('App v1.2');
```
23. Commitez "Bump to 1.2 on main"

24. Sur `feature/new-ui`, tentez un rebase
25. Git signalera un conflit

### √âtape 7 : R√©solution du conflit de rebase

26. Ouvrez `main.js` et r√©solvez le conflit
27. Utilisez `git add` pour marquer comme r√©solu
28. Continuez le rebase avec `git rebase --continue`
29. V√©rifiez l'historique final

### √âtape 8 : Comparaison rebase vs merge

30. Cr√©ez une branche `feature/compare`
31. Faites quelques commits
32. Cr√©ez une copie : `feature/compare-merge`
33. Sur compare : rebasez sur main
34. Sur compare-merge : mergez main
35. Comparez les graphes des deux branches

## ‚úÖ Validation

```bash
# Historique lin√©aire apr√®s rebase
git log --oneline --graph feature/new-ui

# Diff√©rence de graphe
git log --oneline --graph --all
```

‚ö†Ô∏è **IMPORTANT** : Ne jamais rebase des commits d√©j√† push√©s sur remote partag√© !

---

# TP10 - Pull Requests - Code Review

## üéØ Objectifs

- Cr√©er une Pull Request sur GitHub
- Faire une code review
- G√©rer les commentaires et modifications
- Merger une PR

## üìù Contexte

Vous avez d√©velopp√© une nouvelle fonctionnalit√©. Avant de l'int√©grer dans main, votre √©quipe utilise des Pull Requests pour la revue de code.

## üîß Instructions

### √âtape 1 : Setup GitHub

1. Cr√©ez un repository `pr-workflow` sur GitHub
2. Clonez-le en local
3. Cr√©ez `README.md` :
```markdown
# PR Workflow Demo

Projet pour apprendre les Pull Requests.
```
4. Commitez et poussez sur main

### √âtape 2 : D√©veloppement de feature

5. Cr√©ez une branche `feature/user-authentication`
6. Cr√©ez `auth.js` :
```javascript
class Auth {
    constructor() {
        this.users = [];
    }
    
    register(username, password) {
        this.users.push({ username, password });
        return true;
    }
}
```
7. Commitez "Add user registration"

8. Ajoutez une m√©thode :
```javascript
    login(username, password) {
        const user = this.users.find(u => 
            u.username === username && u.password === password
        );
        return user !== undefined;
    }
```
9. Commitez "Add login functionality"

10. Poussez la branche sur GitHub

### √âtape 3 : Cr√©er la Pull Request

11. Sur GitHub, allez dans "Pull Requests"
12. Cliquez "New Pull Request"
13. Base: `main`, Compare: `feature/user-authentication`
14. Titre : "Add user authentication system"
15. Description :
```markdown
## Changes
- Added Auth class
- Implemented registration
- Implemented login

## Testing
- [ ] Manual testing done
- [ ] Unit tests to be added

## Notes
Password storage needs to be improved with hashing.
```
16. Cr√©ez la PR

### √âtape 4 : Code Review (simulation)

17. Sur GitHub, examinez les fichiers chang√©s
18. Ajoutez un commentaire sur la ligne du password :
> "‚ö†Ô∏è Passwords should be hashed, not stored in plain text"

19. Ajoutez un commentaire g√©n√©ral :
> "Good start! Please add password hashing before merge."

### √âtape 5 : Modifications suite √† review

20. En local, sur la m√™me branche, modifiez `auth.js` :
```javascript
    register(username, password) {
        const hashedPassword = this.hashPassword(password);
        this.users.push({ username, password: hashedPassword });
        return true;
    }
    
    hashPassword(password) {
        // Simple hash (in production, use bcrypt)
        return btoa(password);
    }
    
    login(username, password) {
        const hashedPassword = this.hashPassword(password);
        const user = this.users.find(u => 
            u.username === username && u.password === hashedPassword
        );
        return user !== undefined;
    }
```
21. Commitez "Add password hashing"
22. Poussez - la PR se met √† jour automatiquement

### √âtape 6 : Approbation et Merge

23. Sur GitHub, v√©rifiez les nouveaux commits
24. Approuvez la PR (bouton "Approve")
25. Mergez la PR avec "Merge Pull Request"
26. Choisissez un message de merge
27. Confirmez le merge
28. Supprimez la branche sur GitHub

### √âtape 7 : Synchronisation locale

29. En local, basculez sur `main`
30. Pullez les changements
31. V√©rifiez que votre feature est dans main
32. Supprimez la branche locale feature

### √âtape 8 : PR avec conflits

33. Cr√©ez `feature/logout`
34. Ajoutez une m√©thode logout dans `auth.js`
35. Commitez et poussez
36. Cr√©ez une PR

37. Sur main (via GitHub ou local), modifiez `auth.js`
38. Pushez sur main

39. La PR affiche maintenant des conflits
40. En local, sur feature/logout :
    - Pullez main
    - R√©solvez les conflits
    - Poussez
41. La PR devrait maintenant √™tre mergeable

## ‚úÖ Validation

Sur GitHub :
- [ ] PR cr√©√©e avec description compl√®te
- [ ] Commentaires de review ajout√©s
- [ ] Modifications effectu√©es suite √† review
- [ ] PR merg√©e avec succ√®s
- [ ] Branche supprim√©e apr√®s merge

En local :
```bash
# Main √† jour
git pull origin main

# Branches nettoy√©es
git branch -d feature/user-authentication

# Historique propre
git log --oneline --graph
```

## üéì Bonnes pratiques

1. **Titre de PR** : Clair et descriptif
2. **Description** : Contexte, changements, tests
3. **Petites PR** : Plus faciles √† review
4. **Tests** : Toujours inclure
5. **Commentaires constructifs** : Sugg√©rer, pas critiquer
6. **R√©ponse rapide** : Ne pas laisser tra√Æner les PR

---

**F√©licitations ! Vous ma√Ætrisez maintenant le workflow complet Git/GitHub ! üéâ**
